#############################################################
#                  NOIP2018 普及组试题                      #
#############################################################


👈👈👈👈👈👈👈👈👈👈👈👈👈 T1 标题统计 👉👉👉👉👉👉👉👉👉👉👉👉
✳ 题目描述 ✳
凯凯刚写了一篇美妙的作文，请问这篇作文的标题中有多少个字符？ 注意：标题中可能包含大、小写英文字母、数字字符、空格和换行符。统计标题字 符数时，空格和换行符不计算在内。

✳ 输入输出格式 ✳
输入格式：
输入文件只有一行，一个字符串 ss。

输出格式：
输出文件只有一行，包含一个整数，即作文标题的字符数（不含空格和换行符）。

输入输出样例
输入样例#1：
234
输出样例#1：
3
输入样例#2：
Ca 45
输出样例#2：
4
说明
【输入输出样例 1 说明】
标题中共有 3
3 个字符，这 3

3 个字符都是数字字符。

【输入输出样例 2 说明】
标题中共有 5
5 个字符，包括 11 个大写英文字母， 11 个小写英文字母和 22 个数字字符， 还有 11 个空格。由于空格不计入结果中，故标题的有效字符数为 4

4 个。

【数据规模与约定】
规定 ∣s∣
∣s∣ 表示字符串 ss 的长度（即字符串中的字符和空格数）。
对于 40%40% 的数据，1≤∣s∣≤51≤∣s∣≤5，保证输入为数字字符及行末换行符。
对于 80%80% 的数据，1≤∣s∣≤51≤∣s∣≤5，输入只可能包含大、小写英文字母、数字字符及行末换行符。
对于 100%100% 的数据，1≤∣s∣≤51≤∣s∣≤5，输入可能包含大、小写英文字母、数字字符、空格和行末换行符。

👈👈👈👈👈👈👈👈👈👈👈👈👈 T2 龙虎斗 👉👉👉👉👉👉👉👉👉👉👉👉

✳ 题目描述 ✳
轩轩和凯凯正在玩一款叫《龙虎斗》的游戏，游戏的棋盘是一条线段，线段上有 n 个兵营（自左至右编号 1∼n），相邻编号的兵营之间相隔 11 厘米，即棋盘为长度为 n−1 厘米的线段。i 号兵营里有 ci​​ 位工兵。 下面图 1 为 n=6 的示例：

🐉⚪一一⚪一一⚪一一⚪一一⚪一一⚪🐅
   1     2     3     4     5     6

轩轩在左侧，代表“龙”；凯凯在右侧，代表“虎”。 他们以 m 号兵营作为分界， 靠左的工兵属于龙势力，靠右的工兵属于虎势力，而第m 号兵营中的工兵很纠结，他们不属于任何一方。
一个兵营的气势为：该兵营中的工兵数 × 该兵营到 m 号兵营的距离；参与游戏 一方的势力定义为：属于这一方所有兵营的气势之和。
下面图 2 为 n=6,m=4 的示例，其中红色为龙方，黄色为虎方：
                       m=4
🐉 □ 一一 □ 一一 □ 一一⚪一一 ■ 一一 ■ 🐅
   1      2      3      4     5      6
游戏过程中，某一刻天降神兵，共有 s1​ 位工兵突然出现在了 p1​​ 号兵营。作为轩轩和凯凯的朋友，你知道如果龙虎双方气势差距太悬殊，轩轩和凯凯就不愿意继续玩下去了。为了让游戏继续，你需要选择一个兵营 p2​ ，并将你手里的 s2​ 位工兵全部派往 兵营 p2​，使得双方气势差距尽可能小。
注意：你手中的工兵落在哪个兵营，就和该兵营中其他工兵有相同的势力归属（如果落在 m 号兵营，则不属于任何势力）。
输入输出格式
输入格式：
输入文件的第一行包含一个正整数n，代表兵营的数量。
接下来的一行包含 n 个正整数，相邻两数之间以一个空格分隔，第 i 个正整数代 表编号为 i 的兵营中起始时的工兵数量 ci​ 。
接下来的一行包含四个正整数，相邻两数间以一个空格分隔，分别代表 m, p1​, s1​, s2​ 。
输出格式：
输出文件有一行，包含一个正整数，即 p2​ ，表示你选择的兵营编号。如果存在多个编号同时满足最优，取最小的编号。
输入输出样例
输入样例#1：
6
2 3 2 3 2 3
4 6 5 2
输出样例#1：
2
输入样例#2：
6
1 1 1 1 1 16
5 4 1 1
输出样例#2：
1
说明
【输入输出样例 1 说明】
见问题描述中的图 2。
双方以 m=4
m=4 号兵营分界，有 s1​=5 位工兵突然出现在 p1​=6 号兵营。 龙方的气势为：
2×(4−1)+3×(4−2)+2×(4−3)=14
虎方的气势为：
2×(5−4)+(3+5)×(6−4)=18
当你将手中的 s2​=2 位工兵派往 p2​=2 号兵营时，龙方的气势变为：
14+2×(4−2)=18
此时双方气势相等。
【输入输出样例 2 说明】
双方以 m=5 号兵营分界，有 s1​=1 位工兵突然出现在 p1​=4 号兵营。
龙方的气势为：
1×(5−1)+1×(5−2)+1×(5−3)+(1+1)×(5−4)=11
虎方的气势为：
16×(6−5)=16
当你将手中的 s2​=1 位工兵派往 p2​=1 号兵营时，龙方的气势变为：
11+1×(5−1)=15
此时可以使双方气势的差距最小。
【数据规模与约定】
1<m<n,1≤p1​≤n
对于 20% 的数据，n=3, m=2,ci​=1,s1​,s2​≤100
另有 20% 的数据，n≤10, p1​=m,ci​=1,s1​,s2​≤100
对于 60% 的数据，n≤100, ci​=1,s1​,s2​≤100
对于 80% 的数据，n≤100, ci​,s1​,s2​≤100
对于 100% 的数据，n≤10^5, ci,s1,s2≤10^9

👈👈👈👈👈👈👈👈👈👈👈👈👈 T3 摆渡车 👉👉👉👉👉👉👉👉👉👉👉👉

✳ 题目描述 ✳
有 n 名同学要乘坐摆渡车从人大附中前往人民大学，第 i 位同学在第 ti​ 分钟去等车。只有一辆摆渡车在工作，但摆渡车容量可以视为无限大。摆渡车从人大附中出发， 把车上的同学送到人民大学，再回到人大附中（去接其他同学），这样往返一趟总共花费 m 分钟（同学上下车时间忽略不计）。摆渡车要将所有同学都送到人民大学。
凯凯很好奇，如果他能任意安排摆渡车出发的时间，那么这些同学的等车时间之和最小为多少呢？
注意：摆渡车回到人大附中后可以即刻出发。
输入输出格式
输入格式：
第一行包含两个正整数 n,m，以一个空格分开，分别代表等车人数和摆渡车往返 一趟的时间。
第二行包含 n 个正整数，相邻两数之间以一个空格分隔，第 i 个非负整数 ti​ 代 表第 i 个同学到达车站的时刻。
输出格式：
输出一行，一个整数，表示所有同学等车时间之和的最小值（单位：分钟）。
输入输出样例
输入样例#1：
5 1
3 4 4 3 5
输出样例#1：
0
输入样例#2：
5 5
11 13 1 5 5
输出样例#2：
4
✳ 说明 ✳
【输入输出样例 1 说明】
同学 1 和同学 4 在第 3 分钟开始等车，等待 0 分钟，在第 3 分钟乘坐摆渡车出发。摆渡车在第 4 分钟回到人大附中。
同学 2 和同学 3 在第 4 分钟开始等车，等待 0 分钟，在第 4 分钟乘坐摆渡车 出发。摆渡车在第 5 分钟回到人大附中。
同学 5 在第 5 分钟开始等车，等待 0 分钟，在第 5 分钟乘坐摆渡车出发。自此 所有同学都被送到人民大学。总等待时间为 0。
【输入输出样例 2 说明】
同学 3 在第 1 分钟开始等车，等待 0 分钟，在第 1 分钟乘坐摆渡车出发。摆渡 车在第 6 分钟回到人大附中。
同学 4 和同学 5 在第 5 分钟开始等车，等待 1 分钟，在第 6 分钟乘坐摆渡车 出发。摆渡车在第 11 分钟回到人大附中。
同学 1 在第 11 分钟开始等车，等待 2 分钟；同学 2 在第 13 分钟开始等车， 等待 0 分钟。他/她们在第 13 分钟乘坐摆渡车出发。自此所有同学都被送到人民大学。 总等待时间为 4。
可以证明，没有总等待时间小于 4 的方案。
【数据规模与约定】
对于 10% 的数据，n≤10, m=1, 0≤ti​≤100
对于 30% 的数据，n≤20, m≤2, 0≤ti​≤100
对于 50% 的数据，n≤500, m≤100, 0≤ti​≤10^4
另有 20% 的数据，n≤500, m≤10, 0≤ti​≤4×10^6
对于 100% 的数据，n≤500, m≤100, 0≤ti​≤4×10^6

动态规划
用一个三维数组dp[i][j][k]表示到第i个人时车还有j分钟到且现在有k个人在等车时，最后最小的等车时间。那么问题的解即为dp[1][0][1]
状态转移方程如下：
	wait[i]表示第i个人到第i+1个人之见的时间差
（1） j > wait[i]

         +------------- j --------------------------+
         i                            i+1           |
         +------------------------------------------+
         |                            |
         +----------------------------+
                      wait[i]
第i+1个人的状态中，车离第i+1个人的距离为j-wait[i]，而等车的人数比现在第i个人的状态多一个，因为有k个人在等这班车，所以时间还要加上一个k*wait[i]，此时：

    dp[i][j][k] = dp[i + 1][j - wait[i]][k + 1] + k * wait[i]

（2） j <= wait[i]

第一种情况，第i+1个人也要坐这一班车（如图）
		 +------------- j --------------------+
		 |                                    |
		i+------------------------------------+-------------+ i+1
		 |                                                  |
		 +--------------------------------------------------+
					  wait[i]
此时第i+1个人到了之后是不需要等车的，所以他刚刚到就可以坐上车，所以第i+1个人的状态中，车已经在等他了，所以j就为0，等车人数当然也要多一个，和上一种情况一样，也有k个人在等车，时间也要加上一个k*wait[i]，此时：

    dp[i][j][k] = dp[i + 1][0][k + 1] + k * wait[i]

第二种情况，第i+1个人不坐这班车（如图）
		 +------------- j -----------+---------- m -----------+
		 |                           |                        |
		i+---------------------------+----------------+-------+ i+1
		 |                                            |
		 +--------------------------------------------+
					  wait[i]
此时第i+1个人的车还有j+m-wait[i]分钟才能到，因为第i+1个人不坐这班车，所以上一状态等车的人就只有一个了，此时dp[i][j][k]=dp[i + 1][j + m - wait[i]][1] + k*j

第三种情况
		 +-------------+j+-----------+-----------m+-------+
		 |                           |                    |      i+1
		i+---------------------------+--------------------+------+
		 |                                                       |
		 +-------------------------------------------------------+
					  wait[i]
j+m-wait[i]是一个负数，第i+1个人根本就不用等车，所以应该是和0来作比较，此时：dp[i][j][k] = dp[i + 1][0])][1]

综合二、三可得

    dp[i][j][k] = dp[i + 1][max(0, j + m - wait[i])][1]
综合一、二、三可得
	dp[i][j][k] = min(dp[i + 1][0][k + 1] + k * wait[i], dp[i + 1][max(0, j + m - wait[i])][1] + k * j)


 +------------------+j+------------+
 |                                 |
n+---------------------------------+
对第n个人，假设车还有i分钟到，此时有j人在等车，那么：

    dp[n][i][j] = i * j


👈👈👈👈👈👈👈👈👈👈👈👈👈 T4 树 👉👉👉👉👉👉👉👉👉👉👉👉

✳ 题目描述 ✳
一棵有点权的有根树如果满足以下条件，则被轩轩称为对称二叉树：
	1. 二叉树；
	2. 将这棵树所有节点的左右子树交换，新树和原树对应位置的结构相同且点权相等。
下图中节点内的数字为权值，节点外的 id 表示节点编号。

对称二叉树
                    id=1
                   +---+
          +--------+ 3 +---------+
          |        +---+         |
     id=2 v                      v id=3
        +-+-+                  +-+-+
     +--+ 4 +---+           +--+ 4 +---+
     |  +---+   |           |  +---+   |
id=4 v          v id=5 id=6 v          v id=7
   +-+-+      +-+-+       +-+-+      +-+-+
   | 5 |      | 1 |       | 1 |      | 5 |
   +---+      +---+       +---+      +---+

非对称二叉树
                    id=1
                   +---+
          +--------+ 3 +---------+
          |        +---+         |
     id=2 v                      v id=3
        +-+-+                  +-+-+
     +--+ 4 +---+           +--+ 4 +---+
     |  +---+   |           |  +---+   |
id=4 v          v id=5 id=6 v          v id=7
   +-+-+      +-+-+       +-+-+      +-+-+
   | 5 |      | 2 |       | 1 |      | 5 |
   +---+      +---+       +---+      +---+

                    id=1
                   +---+
          +--------+ 3 +---------+
          |        +---+         |
     id=2 v                      v id=3
        +-+-+                  +-+-+
     +--+ 4 +---+           +--+ 4 +
     |  +---+   |           |  +---+
id=4 v          v id=5 id=6 v
   +-+-+      +-+-+       +-+-+
   | 5 |      | 2 |       | 1 |
   +---+      +---+       +---+

输入格式
第一行一个正整数 n，表示给定的树的节点的数目，规定节点编号 1∼n，其中节点 1 是树根。
第二行 n 个正整数，用一个空格分隔，第 i 个正整数 vi​ 代表节点 i 的权值。
接下来 n 行，每行两个正整数 li​,ri​，分别表示节点 i 的左右孩子的编号。如果不存在左 / 右孩子，则以 −1 表示。两个数之间用一个空格隔开。
输出格式
输出文件共一行，包含一个整数，表示给定的树的最大对称二叉子树的节点数。
输入输出样例
输入 #1
2
1 3
2 -1
-1 -1

输出 #1
1
输入 #2
10
2 2 5 5 5 5 4 4 2 3
9 10
-1 -1
-1 -1
-1 -1
-1 -1
-1 2
3 4
5 6
-1 -1
7 8
输出 #2
3

✳ 说明 ✳
【输入输出样例 1 说明】
               id=1
              +---+
     +--------+ 1 |
     |        +---+
id=2 v
   +-+-+
   | 3 |
   +---+
最大的对称二叉子树为以节点 2 为树根的子树，节点数为 1。

【输入输出样例 2 说明】
               id=1
              +---+
     +--------+ 3 +---------+
     |        +---+         |
id=9 |                      | id=10
   +-v-+                  +-v-+
   | 2 |            +-----+ 3 +------+
   +---+            |     +---+      |
               id=7 |                |  id=8
                  +-v-+            +-v-+
                +-+ 4 +-+      +---+ 4 +---+
                | +---+ |      |   +---+   |
           id=3 |   id=4|      |id=5       | id=6
              +-v-+   +-v-+  +-v-+       +-v-+
              | 5 |   | 5 |  | 5 |       | 5 +---+
              +---+   +---+  +---+       +---+   |
                                                 |
                                           id=2  |
                                               +-v-+
                                               | 2 |
                                               +---+

最大的对称二叉子树为以节点 7 为树根的子树，节点数为 3。

【数据规模与约定】
共 25 个测试点。
vi​≤1000。
测试点 1∼3,n≤10，保证根结点的左子树的所有节点都没有右孩子，根结点的右 子树的所有节点都没有左孩子。
测试点 4∼8,n≤10。
测试点 9∼12,n≤10^5，保证输入是一棵“满二叉树” 。
测试点 13∼16,n≤10^5，保证输入是一棵“完全二叉树”。
测试点 17∼20,n≤10^5，保证输入的树的点权均为 1。
测试点 21∼25,n≤10^6。
本题约定：
层次：节点的层次从根开始定义起，根为第一层，根的孩子为第二层。树中任一节 点的层次等于其父亲节点的层次加 1。
树的深度：树中节点的最大层次称为树的深度。
满二叉树：设二叉树的深度为 h，且二叉树有 2h−1 个节点，这就是满二叉树。

【解题】
暴力遍历，使用递归的方法，求每一个结点处的最大对称值。
每次对比的两个结点分别是左和右，如果是叶子结点，直接比对内容。如果是中间结点，分别对称的比较左右结点（下一级的右对左，左对右）。

